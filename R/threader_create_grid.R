#' Step 3: Construct the Grid of Estimates
#'
#' @param all_entries_fpath The filepath to the combined .rds file generated by `threader_combine()`.
#' @param spec_fpath The filepath to the `.yaml`-format spec file
#'
#' @return Wide-format tibble, with one row per unit of observation and one column per unit of time
#' @export
#'
#' @examples
#' grid_df <- threader_create_grid()
threader_create_grid <- function(all_entries_fpath = NULL,
                                 spec_fpath = NULL) {
  if (is.null(all_entries_fpath)) {
    all_entries_fpath <- demo_all_entries_fpath()
  }
  if (is.null(spec_fpath)) {
    spec_fpath <- demo_spec_fpath()
  }
  # Saving to the same directory as the all_entries.rds file
  output_path <- dirname(all_entries_fpath)
  # Load the combined file
  combined_df <- readRDS(all_entries_fpath)
  spec <- .parse_spec_file(spec_fpath)
  grid_varname <- .spec_get_varname(spec)
  grid_unit <- .spec_get_unit(spec)
  grid_time_varname <- .spec_get_time_varname(spec)
  grid_time_start <- .spec_get_time_start(spec)
  grid_time_end <- .spec_get_time_end(spec)
  grid_exclude <- .spec_get_excluded(spec)
  # And create!
  result <- .create_grid(combined_df, grid_varname, grid_unit, grid_time_varname,
                        grid_time_start, grid_time_end, output_path, exclude=grid_exclude)
  return(result)
}

.create_grid <- function(estimates_df, grid_varname, unit_of_obs, time_varname,
                        time_start, time_end, output_path, exclude = NULL){
  message(paste0("=====[ creating grid for [",grid_varname,"] x [",unit_of_obs,"], t={",time_start,", ..., ",time_end,"} ]====="))
  ## And the source-trustworthiness file
  #trust_fpath = os.path.join(pl.input_path, "trust.csv")
  #trust_df = pd.read_csv(trust_fpath)
  #init_trust_dict(trust_df)
  # Get all the entries for the var we care about
  estimates_df <- estimates_df %>%
    dplyr::filter(varname == grid_varname)
  # And now filter to the ones within range
  estimates_df <- estimates_df %>%
    dplyr::filter((!!as.symbol(time_varname) >= time_start) & (!!as.symbol(time_varname) <= time_end))
  # And remove langs/countries in exclude list
  if (!is.null(exclude)) {
    estimates_df <- estimates_df %>%
      dplyr::filter(!(!!as.symbol(unit_of_obs) %in% exclude))
  }
  ## Print a summary of the years+units spanned
  # Get the unique years
  unique_times <- estimates_df %>%
    dplyr::distinct(!!as.symbol(time_varname)) %>%
    dplyr::arrange(!!as.symbol(time_varname))
  .print_summary(time_varname, unique_times)
  ## And a summary of the langs/countries
  unique_units <- estimates_df %>%
    dplyr::distinct(!!as.symbol(unit_of_obs)) %>%
    dplyr::arrange(!!as.symbol(unit_of_obs))
  .print_summary(unit_of_obs, unique_units)
  ## Now we can create the grid, starting with the index column
  num_df_long <- dplyr::cross_join(unique_units, unique_times)
  info_df_long <- num_df_long
  #return_obj <- list(num_df=num_df_long, combined_df=combined_df)
  # Aggregate the combined df so there's one value per country x year
  agg_df <- estimates_df %>%
    dplyr::group_by(!!as.symbol(unit_of_obs), !!as.symbol(time_varname)) %>%
    dplyr::summarise(est = mean(value))
  # And now merge so that we have a full grid, even for cells without any estimates
  # num_df_long has every possible country x year combo, so we want to left merge
  # the estimates into that
  num_df_merged <- num_df_long %>%
    dplyr::left_join(agg_df, by=c(unit_of_obs,time_varname))
  info_df_merged <- info_df_long %>%
    dplyr::mutate(info = "")
  # Save these completed but long-form dfs
  .save_dfs(num_df_merged, info_df_merged, output_path, grid_varname, "_long")
  # Finally, un-pivot it, so that it's back to being a wide-form grid
  num_df_wide <- num_df_merged %>%
    tidyr::pivot_wider(names_from = as.symbol(time_varname),
                       values_from = "est")
  info_df_wide <- info_df_merged %>%
    tidyr::pivot_wider(names_from = as.symbol(time_varname),
                       values_from = "info")
  #num_df_grid <- num_df_merged %>% tidyr::pivot_wider()
  # And save the grids
  saved_fpaths <- .save_dfs(num_df_wide, info_df_wide, output_path,
                            grid_varname, "_wide")
  num_fpath <- saved_fpaths$num
  info_fpath <- saved_fpaths$info
  # And return the dfs
  return_obj <- list(num_df=num_df_wide, info_df=info_df_wide,
                     num_fpath=num_fpath, info_fpath=info_fpath)
  return(return_obj)
}

#' Produces estimate list, formatted for Google Sheet, from the provided df
#'
#' @param estimate_df The tibble you want a summary of
#' @param unit_of_obs The name of the variable you want to summarize by
#'
#' @return A list where each line is the summary of a row in `estimate_df`
.get_estimate_list <- function(estimate_df, unit_of_obs) {
  estimate_strs <- estimate_df %>% tibble::rowid_to_column(var="index") %>%
    tidyr::unite("values", c(!!as.symbol(unit_of_obs), rlang::.data$value), sep=" ") %>%
    tidyr::unite("output", c(rlang::.data$index, rlang::.data$values), sep=": ") %>%
    dplyr::select(rlang::.data$output) %>% as.list()
  return(estimate_strs)
  #return [f"{rnum}: {rtuple[1]['value']} ({rtuple[1]['source_id']})" for rnum, rtuple in enumerate(estimate_df.iterrows())]
}

#' Prints just the first two and last two entries, with "..." in between, unless
#' `print_all` is set to True
#'
#' @param var_name The name of the variable you're printing information about
#' @param val_list The list of values that this variable can take on
#' @param print_all If `FALSE`, only the first and last 2 values are printed.
#'
#' @return Nothing: it just prints the values
.print_summary <- function(var_name, val_list, print_all = FALSE) {
  print(paste0("Values for grid axis [",var_name,"]:"))
  if (print_all) {
    print(val_list)
    return()
  }
  if (length(val_list) <= 4) {
    print(val_list)
  } else {
    print(paste0("[",val_list[0],", ",val_list[1],", ..., ",val_list[-2],", ",val_list[-1],"]"))
  }
}

#' Helper function that saves the numeric and info dfs together
#'
#' @param num_df The (long- or wide-format) numeric-estimate tibble you want to save
#' @param info_df The (long- or wide-format) string-info tibble you want to save
#' @param output_path The path to the directory you want the dfs saved in
#' @param grid_varname The name of the main variable you're estimating, use as the prefix to the filename for each saved file.
#' @param fname_suffix A suffix added to the end of each filename. Defaults to `"_long"`, so you'll need to specify `"_wide"` to differentiate the latter format in the filenames.
#'
#' @return An environment with keys `num`, the filepath to the saved numeric `.rds` file, and `info`, the filepath to the saved info-grid `.rds` file.
#'
#' save_results <- .save_dfs(num_df, info_df, "./data/parsed/", "cp_membership_num", "_long")
.save_dfs <- function(num_df, info_df, output_path, grid_varname,
                      fname_suffix = "_long") {
  num_fname_prefix = paste0(grid_varname,"_num",fname_suffix)
  num_rds_fpath = file.path(output_path, paste0(num_fname_prefix,".rds"))
  saveRDS(num_df, num_rds_fpath)
  info_fname_prefix = paste0(grid_varname,"_info",fname_suffix)
  info_rds_fpath = file.path(output_path, paste0(info_fname_prefix,".rds"))
  saveRDS(info_df, info_rds_fpath)
  # And finally, .csv versions for human reading
  num_csv_fpath = file.path(output_path, paste0(num_fname_prefix,".csv"))
  readr::write_csv(num_df, num_csv_fpath)
  info_csv_fpath = file.path(output_path, paste0(info_fname_prefix,".csv"))
  readr::write_csv(info_df, info_csv_fpath)
  return_obj <- list(num=num_rds_fpath, info=info_rds_fpath)
}
